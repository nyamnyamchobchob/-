<!--
Korean History Quiz - Single-file app (index.html)
Updated: Session queue implementation so a chosen keyword runs a continuous problem session
Drop this file into a GitHub Pages repo (root) as `index.html` and enable Pages (main branch) to publish.

Features implemented in this file (updated):
- All previous features preserved (load JSON/CSV, stats, match/chosung question types, localStorage stats)
- **Session queue**: when a user selects a keyword (or Random), a session queue is created containing one question per data item. The user continues solving questions in that queue without returning to the menu automatically.
  * Each queue entry is either a 'match' or 'chosung' question. Types are assigned so repeated sessions will tend to alternate formats (stored round counter).
  * After the queue is exhausted, the user can choose to [다시 시작] (reshuffle and continue) or [메뉴로 돌아가기].
- Questions are consumed (no repeats) until the queue is empty; then repetition is allowed by the user's choice.
- After each answer, the next question is automatically loaded (small visual delay to show feedback).

Limitations / notes:
- Stats stored in localStorage; session preferences use localStorage round counters to alter types between restarts.
- Distractors are taken from the dataset (no semantic distractor generator).

-->

<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>한국사 능력검정 퀴즈 (Session Mode)</title>
  <style>
    :root{--bg:#fbfbfd;--card:#fff;--accent:#0b63d3;--success:#2e7d32;--danger:#c62828}
    html,body{height:100%;margin:0;font-family:Inter, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;background:var(--bg);color:#111}
    .wrap{max-width:900px;margin:0 auto;padding:18px}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    h1{font-size:1.25rem;margin:0}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button, label.input-btn{background:var(--card);border:1px solid #ddd;padding:8px 12px;border-radius:8px;font-size:1rem}
    button:hover{filter:brightness(.98);cursor:pointer}
    #menu{margin-top:18px;display:flex;flex-wrap:wrap;gap:8px}
    .kw-btn{min-width:140px;text-align:left;display:flex;flex-direction:column;padding:10px;border-radius:10px;border:1px solid #e6e7ea;background:#fff}
    .kw-title{font-weight:600}
    .kw-stats{font-size:.85rem;color:#666}
    #quiz{margin-top:18px;padding:14px;border-radius:10px;background:var(--card);border:1px solid #e6e7ea;min-height:120px}
    .question{font-size:1.05rem;margin-bottom:12px}
    .options{display:flex;flex-direction:column;gap:8px}
    .opt{padding:8px 10px;border-radius:8px;border:1px solid #ddd;background:#fff}
    .opt.disabled{opacity:.6;pointer-events:none}
    .opt.correct{border-color:var(--success);background:rgba(46,125,50,0.06)}
    .opt.wrong{border-color:var(--danger);background:rgba(198,40,40,0.05)}
    .meta{margin-top:10px;display:flex;align-items:center;gap:8px}
    .small{font-size:.9rem;color:#666}
    .kbd{font-family:monospace;background:#f4f6fb;padding:4px 8px;border-radius:6px}
    footer{margin-top:18px;color:#777;font-size:.9rem}
    .center{display:flex;gap:8px}
    @media (max-width:480px){.kw-btn{min-width:48%;font-size:.95rem}.controls{flex-direction:column;align-items:stretch}button,label.input-btn{width:100%}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>한국사 능력검정 퀴즈</h1>
        <div class="small">Session 모드: 동일 키워드 선택 시 연속 문제 풀이 가능</div>
      </div>
      <div class="controls">
        <label class="input-btn">Load data <input id="fileInput" type="file" accept="application/json,text/csv" style="display:none"></label>
        <button id="randomBtn">랜덤 문제</button>
        <button id="resetStatsBtn">통계 초기화</button>
      </div>
    </header>

    <main>
      <div id="menu"></div>

      <div id="quiz" style="display:none"></div>

      <div class="meta">
        <button id="backBtn" style="display:none">이전으로</button>
        <div id="currentKeyword" class="small"></div>
        <div id="progress" class="small"></div>
      </div>
    </main>

    <footer>
      <div>데이터 파일 포맷: JSON (권장) 또는 CSV(간단지원). CSV 예: <span class="kbd">고조선,고인돌|비파형 동검|위만조선</span></div>
    </footer>
  </div>

  <script>
    // ---------------------------- Sample data (embedded) ----------------------------
    const DEFAULT_DATA = [
      { keyword: "고조선", data: ["고인돌", "비파형 동검", "위만조선", "우거왕", "왕검성"] },
      { keyword: "삼국시대", data: ["고구려", "백제", "신라", "광개토대왕", "근초고왕"] },
      { keyword: "조선시대", data: ["세종대왕", "훈민정음", "붕당", "영정법", "사화"] }
    ];

    // ---------------------------- State and storage ----------------------------
    let DATA = [];
    let stats = {};

    const STORAGE_KEY = 'kh_quiz_stats_v1';
    const STORAGE_ROUND_KEY = 'kh_quiz_rounds_v1'; // store round counters so restarts alternate formats

    // Session queue
    let sessionQueue = []; // array of question objects
    let currentQuestion = null;
    let sessionMeta = { keyword: null, isRandom: false };

    function loadStats(){
      try{ const raw = localStorage.getItem(STORAGE_KEY); stats = raw ? JSON.parse(raw) : {}; }catch(e){ stats = {}; }
    }
    function saveStats(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(stats)); }
    function resetStats(){ stats = {}; saveStats(); renderMenu(); }

    function loadRounds(){
      try{ const raw = localStorage.getItem(STORAGE_ROUND_KEY); return raw ? JSON.parse(raw) : {}; }catch(e){ return {}; }
    }
    function saveRounds(r){ localStorage.setItem(STORAGE_ROUND_KEY, JSON.stringify(r)); }

    // ---------------------------- Utility helpers ----------------------------
    function sample(arr, n=1){
      const copy = arr.slice();
      const out = [];
      for(let i=0;i<n && copy.length;i++){
        const idx = Math.floor(Math.random()*copy.length);
        out.push(copy.splice(idx,1)[0]);
      }
      return out;
    }
    function shuffleInPlace(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
    function uniq(arr){ return Array.from(new Set(arr)); }

    // 초성 추출
    const CHO = ["ㄱ","ㄲ","ㄴ","ㄷ","ㄸ","ㄹ","ㅁ","ㅂ","ㅃ","ㅅ","ㅆ","ㅇ","ㅈ","ㅉ","ㅊ","ㅋ","ㅌ","ㅍ","ㅎ"];
    function chosungOf(str){
      let out = '';
      for(const ch of str){
        const code = ch.charCodeAt(0);
        if(code >= 0xAC00 && code <= 0xD7A3){
          const index = Math.floor((code - 0xAC00) / 588);
          out += CHO[index] || ch;
        } else if (/[A-Za-z0-9]/.test(ch)){
          out += ch; // keep ascii
        } else if (ch.trim()===""){
          out += ' ';
        } else {
          out += ch;
        }
      }
      return out.replace(/\s+/g,'').trim();
    }

    // ---------------------------- Data loading (file/embedded) ----------------------------
    function useDefaultData(){ DATA = JSON.parse(JSON.stringify(DEFAULT_DATA)); renderMenu(); }

    function parseCSV(text){
      const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(l=>l);
      const out = [];
      for(const line of lines){
        const parts = line.split(',');
        if(parts.length < 2) continue;
        const keyword = parts[0].trim();
        const rest = parts.slice(1).join(',').trim();
        const items = rest.includes('|') ? rest.split('|') : (rest.includes(';') ? rest.split(';') : rest.split('|'));
        const data = items.map(s=>s.trim()).filter(s=>s);
        if(keyword && data.length) out.push({keyword, data});
      }
      return out;
    }

    document.getElementById('fileInput').addEventListener('change', async (ev)=>{
      const f = ev.target.files[0];
      if(!f) return;
      const text = await f.text();
      try{
        const parsed = JSON.parse(text);
        if(Array.isArray(parsed)){
          // merge into DATA
          DATA = DATA.concat(parsed.map(item => ({keyword: item.keyword, data: item.data.slice()})));
          alert('JSON 데이터 로드 완료'); renderMenu(); return;
        }
      }catch(e){
        const csv = parseCSV(text);
        if(csv.length){ DATA = DATA.concat(csv); alert('CSV 데이터 로드 완료'); renderMenu(); return; }
      }
      alert('파일 포맷을 인식하지 못했습니다. JSON이나 CSV (keyword,data1|data2|...) 를 사용하세요.');
    });

    // ---------------------------- UI rendering: menu ----------------------------
    function renderMenu(){
      loadStats();
      document.getElementById('quiz').style.display = 'none';
      document.getElementById('menu').style.display = 'flex';
      document.getElementById('backBtn').style.display = 'none';
      document.getElementById('currentKeyword').textContent = '';
      document.getElementById('progress').textContent = '';

      const menu = document.getElementById('menu');
      menu.innerHTML = '';
      if(!DATA || !DATA.length){ menu.innerHTML = '<div class="small">로드된 데이터가 없습니다. 상단의 Load data로 JSON/CSV 업로드하거나 기본 예제를 사용하세요.</div>'; return; }
      DATA.forEach(item=>{
        if(!stats[item.keyword]) stats[item.keyword] = {correct:0,total:0};
        const btn = document.createElement('button');
        btn.className = 'kw-btn';
        btn.innerHTML = `<div class="kw-title">${item.keyword}</div><div class="kw-stats">${stats[item.keyword].correct}/${stats[item.keyword].total}</div>`;
        btn.addEventListener('click', () => startSession(item.keyword));
        menu.appendChild(btn);
      });
    }

    // ---------------------------- Session queue logic ----------------------------
    function createSessionQueueForKeyword(keyword){
      const itemObj = DATA.find(d=>d.keyword===keyword);
      if(!itemObj) return [];
      const rounds = loadRounds();
      const round = (rounds[keyword]||0);

      // create one question per data item
      const questions = [];
      for(const value of itemObj.data){
        // decide type: alternate based on round to get variety between restarts
        const base = Math.random() < 0.5 ? 'chosung' : 'match';
        const type = (round % 2 === 0) ? base : (base === 'chosung' ? 'match' : 'chosung');
        if(type === 'chosung'){
          questions.push({ keyword, type: 'chosung', value });
        } else {
          // match: create a correct set that always includes this value; sometimes multi
          const maxCorrect = Math.min(3, itemObj.data.length);
          const isMulti = Math.random() < 0.25 && maxCorrect > 1;
          let correctSet = [value];
          if(isMulti){
            // pick one or two additional correct items excluding the main value
            const others = itemObj.data.filter(x=>x!==value);
            const add = sample(others, Math.min(1, others.length));
            correctSet = uniq(correctSet.concat(add));
          }
          questions.push({ keyword, type: 'match', correctSet });
        }
      }
      shuffleInPlace(questions);
      return questions;
    }

    function createSessionQueueRandom(){
      const rounds = loadRounds();
      // use a per-keyword round but we will generate a flat list with types
      const all = [];
      for(const itemObj of DATA){
        const keyword = itemObj.keyword;
        const round = (rounds[keyword]||0);
        for(const value of itemObj.data){
          const base = Math.random() < 0.5 ? 'chosung' : 'match';
          const type = (round % 2 === 0) ? base : (base === 'chosung' ? 'match' : 'chosung');
          if(type === 'chosung') all.push({keyword, type:'chosung', value});
          else{
            const maxCorrect = Math.min(3, itemObj.data.length);
            const isMulti = Math.random() < 0.25 && maxCorrect > 1;
            let correctSet = [value];
            if(isMulti){
              const others = itemObj.data.filter(x=>x!==value);
              const add = sample(others, Math.min(1, others.length));
              correctSet = uniq(correctSet.concat(add));
            }
            all.push({keyword, type:'match', correctSet});
          }
        }
      }
      shuffleInPlace(all);
      return all;
    }

    function startSession(keyword){
      sessionQueue = createSessionQueueForKeyword(keyword);
      sessionMeta.keyword = keyword; sessionMeta.isRandom = false;
      document.getElementById('menu').style.display = 'none';
      document.getElementById('quiz').style.display = 'block';
      document.getElementById('backBtn').style.display = 'inline-block';
      updateProgress();
      nextQuestion();
    }

    function startRandomSession(){
      sessionQueue = createSessionQueueRandom();
      sessionMeta.keyword = '랜덤'; sessionMeta.isRandom = true;
      document.getElementById('menu').style.display = 'none';
      document.getElementById('quiz').style.display = 'block';
      document.getElementById('backBtn').style.display = 'inline-block';
      updateProgress();
      nextQuestion();
    }

    function updateProgress(){
      const left = sessionQueue.length + (currentQuestion ? 1 : 0);
      document.getElementById('currentKeyword').textContent = sessionMeta.keyword ? `문제: ${sessionMeta.keyword}` : '';
      document.getElementById('progress').textContent = left ? `남은 문제: ${left}` : '';
    }

    function nextQuestion(){
      if(sessionQueue.length === 0){
        // session finished
        showSessionEnd();
        return;
      }
      currentQuestion = sessionQueue.shift();
      renderQuestion(currentQuestion);
      updateProgress();
    }

    function showSessionEnd(){
      const quiz = document.getElementById('quiz'); quiz.innerHTML = '';
      const msg = document.createElement('div'); msg.className='question'; msg.textContent = '모든 문제를 풀었습니다!'; quiz.appendChild(msg);
      const controls = document.createElement('div'); controls.className='center';
      const restart = document.createElement('button'); restart.textContent = '다시 시작';
      const toMenu = document.createElement('button'); toMenu.textContent = '메뉴로 돌아가기';
      controls.appendChild(restart); controls.appendChild(toMenu); quiz.appendChild(controls);

      restart.addEventListener('click', ()=>{
        // increment round to alternate formats next session
        const rounds = loadRounds();
        if(!sessionMeta.isRandom && sessionMeta.keyword){ rounds[sessionMeta.keyword] = (rounds[sessionMeta.keyword]||0) + 1; }
        saveRounds(rounds);
        if(sessionMeta.isRandom) sessionQueue = createSessionQueueRandom(); else sessionQueue = createSessionQueueForKeyword(sessionMeta.keyword);
        updateProgress(); nextQuestion();
      });
      toMenu.addEventListener('click', ()=>{ renderMenu(); sessionQueue = []; currentQuestion = null; sessionMeta = {keyword:null,isRandom:false}; });

      document.getElementById('progress').textContent = '';
    }

    // ---------------------------- Render a single question ----------------------------
    function renderQuestion(q){
      const quiz = document.getElementById('quiz'); quiz.innerHTML='';
      if(q.type === 'chosung') renderChosungQuestion(q);
      else renderMatchQuestion(q);
    }

    // collect distractors from whole dataset excluding provided set
    function collectDistractors(excludeSet, count){
      const pool = DATA.flatMap(d => d.data).filter(x => !excludeSet.has(x));
      return sample(pool, Math.min(count, pool.length));
    }

    function renderMatchQuestion(q){
      const itemObj = DATA.find(d=>d.keyword === q.keyword);
      const quiz = document.getElementById('quiz');
      const question = document.createElement('div'); question.className='question';
      const correctSet = new Set(q.correctSet);
      const isMulti = correctSet.size > 1;
      question.textContent = `${q.keyword}에 알맞은 것은? ${isMulti ? '(중복)' : ''}`;
      quiz.appendChild(question);

      // prepare options
      const opts = Array.from(correctSet);
      const need = Math.max(0, 4 - opts.length);
      const distractors = collectDistractors(new Set(opts), need);
      const allOpts = uniq(opts.concat(distractors)).slice(0,4);
      shuffleInPlace(allOpts);

      const optionsDiv = document.createElement('div'); optionsDiv.className='options'; quiz.appendChild(optionsDiv);

      if(isMulti){
        const info = document.createElement('div'); info.className='small'; info.textContent = '정답인 항목을 모두 선택하세요.'; quiz.appendChild(info);
        allOpts.forEach(optText => {
          const label = document.createElement('label'); label.className='opt';
          const cb = document.createElement('input'); cb.type='checkbox'; cb.style.marginRight='8px';
          label.appendChild(cb);
          const span = document.createElement('span'); span.textContent = optText; label.appendChild(span);
          optionsDiv.appendChild(label);

          cb.addEventListener('change', ()=>{
            if(cb.checked && !correctSet.has(optText)){
              revealMultiResult(false, optionsDiv, correctSet, optText);
              setTimeout(nextQuestion, 900);
            } else {
              const checked = Array.from(optionsDiv.querySelectorAll('input[type=checkbox]')).filter(i=>i.checked).map(i=>i.parentElement.textContent.trim());
              const checkedSet = new Set(checked);
              const allCorrectSelected = Array.from(correctSet).every(c => checkedSet.has(c));
              const anyWrongSelected = checked.some(s => !correctSet.has(s));
              if(allCorrectSelected && !anyWrongSelected && checked.length === correctSet.size){
                revealMultiResult(true, optionsDiv, correctSet);
                setTimeout(nextQuestion, 900);
              }
            }
          });
        });

      } else {
        allOpts.forEach(optText => {
          const div = document.createElement('div'); div.className='opt'; div.textContent = optText;
          optionsDiv.appendChild(div);
          div.addEventListener('click', ()=>{
            const isCorrect = correctSet.has(optText);
            Array.from(optionsDiv.children).forEach(c=>c.classList.add('disabled'));
            if(isCorrect){ div.classList.add('correct'); updateStats(q.keyword, true); }
            else { div.classList.add('wrong'); Array.from(optionsDiv.children).forEach(c=>{ if(correctSet.has(c.textContent.trim())) c.classList.add('correct'); }); updateStats(q.keyword, false); }
            setTimeout(nextQuestion, 900);
          });
        });
      }
    }

    function revealMultiResult(isCorrect, optionsDiv, correctSet, wrongChosen=null){
      Array.from(optionsDiv.children).forEach(c => {
        const txt = c.textContent.trim();
        c.classList.add('disabled');
        if(correctSet.has(txt)) c.classList.add('correct');
        if(wrongChosen && txt === wrongChosen) c.classList.add('wrong');
      });
      updateStats(currentQuestion.keyword || currentQuestion?.keyword, isCorrect);
    }

    function renderChosungQuestion(q){
      const quiz = document.getElementById('quiz'); quiz.innerHTML='';
      const question = document.createElement('div'); question.className='question';
      const correct = q.value;
      const chos = chosungOf(correct);
      question.textContent = `초성: ${chos}`;
      quiz.appendChild(question);

      const opts = [correct];
      const dis = collectDistractors(new Set(opts), 3);
      const allOpts = uniq(opts.concat(dis)).slice(0,4);
      shuffleInPlace(allOpts);

      const optionsDiv = document.createElement('div'); optionsDiv.className='options'; quiz.appendChild(optionsDiv);
      allOpts.forEach(opt => {
        const div = document.createElement('div'); div.className='opt'; div.textContent = opt;
        optionsDiv.appendChild(div);
        div.addEventListener('click', ()=>{
          Array.from(optionsDiv.children).forEach(c=>c.classList.add('disabled'));
          if(opt === correct){ div.classList.add('correct'); updateStats(q.keyword, true); }
          else { div.classList.add('wrong'); Array.from(optionsDiv.children).forEach(c=>{ if(c.textContent.trim() === correct) c.classList.add('correct'); }); updateStats(q.keyword, false); }
          setTimeout(nextQuestion, 900);
        });
      });
    }

    function updateStats(keyword, correct){
      if(!stats[keyword]) stats[keyword] = {correct:0,total:0};
      if(correct) stats[keyword].correct++;
      stats[keyword].total++;
      saveStats(); renderMenu();
    }

    // ---------------------------- Buttons ----------------------------
    document.getElementById('backBtn').addEventListener('click', ()=>{
      if(confirm('세션을 종료하고 메뉴로 돌아가시겠어요?')){ renderMenu(); sessionQueue=[]; currentQuestion=null; sessionMeta={keyword:null,isRandom:false}; }
    });

    document.getElementById('randomBtn').addEventListener('click', ()=>{ startRandomSession(); });
    document.getElementById('resetStatsBtn').addEventListener('click', ()=>{ if(confirm('모든 통계를 초기화하시겠어요?')){ resetStats(); } });

    // ---------------------------- Init ----------------------------
    function init(){ loadStats(); useDefaultData(); }
    init();
  </script>
</body>
</html>
